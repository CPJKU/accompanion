#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Main script to run the ACCompanion

This is a copy of the old version, which will be
"""

import argparse
import multiprocessing as mp

from accompanion.predict import main as accompanion
from midi_handling import midi_functions as midif


if __name__ == '__main__':

    parser = argparse.ArgumentParser('ACCompanion')

    parser.add_argument('piece',
                        help='Name of the piece')
    parser.add_argument('--use-dummy-performer',
                        help='Use a MIDI file as the performer',
                        action='store_true', default=False)
    parser.add_argument('--bpm',
                        help='Beats per minute',
                        type=float,
                        default=120.0)
    parser.add_argument('--bm-models', nargs='+',
                        help="One or more model files",
                        default=False)
    parser.add_argument('--use-powermate',
                        help='Use Griffin PowerMate to modify a target',
                        default=None)
    parser.add_argument('--standardize',
                        help='Standardize target',
                        default=None)
    args = parser.parse_args()

    use_xml = True

    if use_xml:
        acc_fn = 'midi_data/{0}/acc-score.xml'.format(args.piece)
        solo_fn = 'midi_data/{0}/humanlead-score.xml'.format(args.piece)
    else:
        acc_fn = 'midi_data/{0}/acc-score.mid'.format(args.piece)
        solo_fn = 'midi_data/{0}/humanlead-score.mid'.format(args.piece)

    perf_midi_fn = 'midi_data/{0}/humanlead.mid'.format(args.piece)

    # Queue to transfer information to the GUI:
    q_gui = mp.Queue()

    # Queue to transfer information for filtered notes:
    q_filter = mp.Queue()

    # List of port numbers
    q_display_ports = mp.Queue()

    # Display the available Midi ports (in a separate process):
    print_process = mp.Process(target=midif.printPorts,
                               args=(q_display_ports,))
    print_process.start()

    # List of port numbers
    ports = q_display_ports.get()

    # Wait for the process to terminate:
    print_process.join()
    print_process.terminate()

    # Select input and output ports
    inport_num = midif.set_port_number(ports[0], 'input')
    outport_num = midif.set_port_number(ports[1], 'output')

    accompanist = mp.Process(name='ACCompanion',
                             target=accompanion,
                             kwargs=dict(
                                 acc_fn=acc_fn,
                                 solo_fn=solo_fn,
                                 perf_midi_fn=perf_midi_fn,
                                 bpm=args.bpm,
                                 inport_num=inport_num,
                                 outport_num=outport_num,
                                 bm_models=args.bm_models,
                                 q_gui=q_gui,
                                 q_filter=q_filter,
                                 use_dummy_performer=args.use_dummy_performer,
                                 use_powermate=args.use_powermate,
                                 standardize=args.standardize))

    try:
        print('start doing stuff')
        accompanist.start()

    except KeyboardInterrupt:
        accompanist.terminate()
